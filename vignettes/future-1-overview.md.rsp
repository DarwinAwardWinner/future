<%@meta language="R-vignette" content="--------------------------------
%\VignetteIndexEntry{A Future for R: An Overview}
%\VignetteAuthor{Henrik Bengtsson}
%\VignetteKeyword{R}
%\VignetteKeyword{package}
%\VignetteKeyword{vignette}
%\VignetteKeyword{future}
%\VignetteKeyword{promise}
%\VignetteEngine{R.rsp::rsp}
%\VignetteTangle{FALSE}
--------------------------------------------------------------------"%>
<%
R.utils::use("R.utils")
use("future")
`%<-%` <- future::`%<-%`
options("withCapture/newline"=FALSE)
options(mc.cores=2L)
%>
# <%@meta name="title"%>

## Introduction
The purpose of the 'future' package is to provide a very simple and uniform way of evaluting R expressions asynchroneously using various resources available to the user.

In programming, a _future_ is an abstraction for a _value_ that may be available at some point in the future.  The state of a future can either be _unresolved_ or _resolved_.  As soon as it is resolved, the value is available instantaneously.  If the value is queried while the future is still unresolved, the current process is _blocked_ until the future is resolved.  It is possible to check whether a future is resolved or not without blocking.  Exactly how and when futures are resolved depends on what strategy is used to evaluate them.  For instance, a future can be resolved using a "lazy" strategy, which means it is resolved only when the value is requested.  Another approach is an "eager" strategy, which means that it starts to resolve the future as soon as it is created.  Yet other strategies may be to resolve futures asynchronously, for instance, by evaluating expressions concurrently on a compute cluster.

Here is an example illustrating how the basics of futures work.  First, consider the following code snippet that uses plain R code:
```r
> v <- {
+   cat("Resolving...\n")
+   3.14
+ }
Resolving...
> v
[1] 3.14
```
It works by assigning the value of an expression to variable `v` and we then print the value of `v`.  Moreover, when the expression for `v` is evaluated we also print a message.

Next, here is the same code snippet modified to use futures instead:
```r
> library("future")
> v %<-% {
+   cat("Resolving...\n")
+   3.14
+ }
Resolving...
> v
[1] 3.14
```
The difference is how `v` is constructed; with plain R we use `<-` whereas with futures we use `%<-%`.

So why are futures useful?  Because we can choose to evaluate the future expression in, for instance, a separate R process by a simple switch of settings:
```r
> library("future")
> plan(multiprocess)
> v %<-% {
+   cat("Resolving...\n")
+   3.14
+ }
> v
[1] 3.14
```
With asynchronous futures the current/main R process is _not_ block and available for further processing while the future is being resolved in a separate process in the background.  In other words, futures provide a simply but yet powerful construct for parallel processing in R.


Now, if you cannot be bothered to read all the nitty-gritty details about futures, but just want to try them out, then skip to the end to play with the Mandelbrot demo using both parallel and non-parallel evaluation.



## Implicit or Explicit Futures

Futures can be created either _implicitly_ or _explicitly_.  In the introductory example above we used _implicit futures_ created via the `v %<-% { expr }` construct.  An alternative is _explicit futures_ using the `f <- future({ expr })` and `v <- value(f)` constructs.  For example, our future example could also be written as:
```r
> library("future")
> f <- future({
+   cat("Resolving...\n")
+   3.14
+ })
> v <- value(f)
Resolving...
> v
[1] 3.14
```

Either style of future construct works equally(*) well.  The implicitly style is most similar to how regular R code is written.  In principal all you have to do is to replace `<-` with a `%<-%` to turn the assigment into a future assignment.  On the other hand, this simplicity can also be decieving, particularly when asynchronous futures are being used.  In contrast, the explicit style makes it much more clear that futures are being used, which lowers the risk for mistakes and better communicates the design to others reading your code.

(*) There are cases where `%<-%` cannot be used without some modifications.  We will return to this in a below section.



To summarize, for explicit futures, we use:

* `f <- future({ expr })` - creates a future
* `v <- value(f)` - gets the value of the future (blocks if not yet resolved)

For implicit futures, we use:

* `v %<-% { expr }` - creates a future and a promise to its value

To keep it simple, we will use the implicit style in the rest of this document.



## Controlling How Futures are Resolved
The future package implements the following types of futures:

| Name            | OSes        | Description
|:----------------|:------------|:-----------------------------------------------------
| _synchronous:_  |             | _non-parallel:_
| eager           | all         |
| lazy            | all         | lazy evaluation - only happens iff value is requested
| transparent     | all         | for debugging (eager w/ early signalling and w/out local)
| _asynchronous:_ |             | _parallel_:
| multiprocess    | all         | multicore iff supported, otherwise multisession
| multisession    | all         | background R sessions (on current machine)
| multicore       | not Windows | forked R processes (on current machine)
| cluster         | all         | external R sessions on current and/or remote machines


By default, future expression are evaluated synchronously (in the current R session) immediately.  This evaluation strategy is referred to as "eager" and we refer to futures using this strategy as "eager futures".  When can explicitly set this strategy using `plan(eager)`.  In this section we will go through each of these strategies and discuss what they have in common and how they differ.

### Coherent Behavior Across Futures
Before going through each of the different future strategies, it could helpful if we talk about some of the design objectives of the future package and the Future API it defines.  When programming with futures, it should not really matter what future strategy will be used when running the code.  This is because we cannot really know what resources the user have access to so the choice of evaluation strategy should be in the hand of the user and not the developer.  In other words, the code should not make any assumptions on type of futures, e.g. synchronous or asynchronous.

One of the designs of the Future API of the future package was designed to encapsulate any differences such that all types of futures will appear to work the same.  This despite the expression may be evaluate locally in the current R process or across the world in a remote R session.  Another obvious advantage of having a consist API and behavior among different types of futures is that it helps prototyping.  Typically one would set up a script using eager evaluation and when fully tested one may turn on asynchronous processing.

Because of this, the defaults of of the different strategies are such that the results and side effects of evaluating a future expression are as similar as possible.  More specifically, the following is true for all futures:

* All _evaluation is done in a local environment_ (e.g. `local({ expr })`) such assignments do not affect the calling environment.  This is natural when evaluating in an external R process, but is also enforced when evaluating in the current R session.

* When a future is constructed, _global variables are identified and validated_.  For lazy evaluation, the globals are also "frozen" (cloned to a local environment) until needed.  For asynchronous evaluation, they are also exported to the R process/session that will be evaluating the future expression.  Regardless of strategy, globals that cannot be located will cause an informative error.  If too large globals (according an option) are about to be exported, an informative error is also generated.

* Future _expressions are only evaluated once_.  As soon as the value has been collected it will be available for all succeeding requests.

Here is an example illustrating that all assignments are done to a local environment:
```r
<%=withCapture({
plan(eager)
a <- 1
x %<-% {
  a <- 2
  2 * a
}
x
a
})%>
```

And here is an example illustrating that globals are validated already when the future is createed:
```r
> rm(b)
> x %<-% { 2 * b }
Error in globalsOf(expr, envir = envir, substitute = FALSE, tweak = tweak,  :
  Identified a global object via static code inspection ({; 2 * b; }), but
failed to locate the corresponding object in the relevant environments: 'b'
```
We will return to global variables and functions at the end of this document.

Now we are ready to explore the different future strategies.


## Synchronous Futures

### Eager Futures
Eager futures are the default unless otherwise specified.  The are designed to behave as similar to regular R evaluation as possible while still fullfilling the Future API and behaviors.  Here is an example illustrating their properties:
```r
<%=withCapture({
plan(eager)
<%@include file="future-1-overview-example2.R"%>
})%>
```
Since eager evaluation is taking place, each of the three futures is resolved instantaneously in the moment it is created.  Note also how `pid`, which is the process ID of the current process, is neither overwritten nor removed.  Since synchronous processing is used, future `b` is evaluated in the current (the calling) process, which is why the value of `b` and `pid` are the same.


### Lazy Futures
A lazy future evaluates its expression only if its value is queried.  It will occur if the future is checked for being resolved or not.  Here is the above example when using lazy evaluation:
```r
<%=withCapture({
plan(lazy)
<%@include file="future-1-overview-example2.R"%>
})%>
```
As previously, variable `pid` is unaffected because all evaluation is done in a local environment.  More interestingly, future `a` is no longer evaluated in the moment it is created, but instead when it is needed the first time, which happens when future `c` is created.  This is because `a` is identified as a global variable that needs to be captured ("frozen" to `a == 3.14`) in order to set up future `c`.  Later when `c` (the value of future `c`) is queried, `a` has already been resolved and only the expression for future `c` is evaluated and `6.14` is obtained.  Moreover, future `b` is just like `a` evaluated only when it is needed the first time, i.e. when `b` is printed.  As for eager evaluation, lazy evaluation is also synchronous which is why `b` and `pid` have the same value.  Finally, notice also how `a` is not re-evaluated when we query the value again.  Actually, with implicit futures, variables `a`, `b` and `c` are all regular values as soon as their futures have been resolved.

_Comment_: Lazy evaluation is already supported by R itself.  Arguments are passed to functions using lazy evaluation.  It is also possible to assign variables  using lazy evaluation using `delayedAssign()`, but contrary to lazy futures this function does not freeze globals.  For more information, see `help("delayedAssign", package="base")`.


## Transparent Futures
[...]



## Asynchronous Futures

### Multisession Futures
Next we will turn to asynchronous futures.  We start with multisession futures because they supported by all operating systems.  A multisession future is evaluated in a background R session running on the same machine as the calling R process.  Here is our example with multisession evaluation:
```r
<%=bfr <- withCapture({
plan(multisession)
<%@include file="future-1-overview-example2.R"%>
})%>
```
The first thing we observe is that the values of `a`, `c` and `pid` are the same are previously.  However, we noticed that `b` is different from before.  This is because the future `b` is evaluated in a different R process and therefore it returns a different process ID.  Another difference is that the messages, generated by `cat()`, are no longer displayed.  This is because they are outputted to the background sessions and not the calling session.


### Multicore Futures
On operating systems where R supports _forking_ of processes, which is basically all operating system but not Windows, an alternative to spawning R sessions in the background is to fork the existing R process.  Forking an R process is considered faster working with a separate R session running in the background.  One reason is that the overhead of exporting large globals to the background session can be greater than when forking is used.  Other than this, the behavior of using multicore evaluation is very similar to using multisession evaluation.  In both cases the evaluation is done on the local machine.

Here is the output from running our example with multicore evaluation:
```r
<%=if (supportsMulticore()) {
withCapture({
plan(multicore)
<%@include file="future-1-overview-example2.R"%>
})
} else {
## If this vignette is compiled on a system not supporting
## multicore processing, let's fake the future based on
## the output of the multisession example
bfr <- gsub("multisession", "multicore", bfr)
bfr <- gsub(b, b+5L, bfr)
bfr
}%>
```
The output and behavior is the same as that for multisession futures, except that a different process ID was used.


### Multiprocess Futures
Sometimes we do not know whether multicore futures are supported or not, but it might still be that we would like to write platform-independent scripts or instructions that works everywhere.  In such cases we can specify that we want to use "multiprocess" futures as in:
```r
plan(multiprocess)
```
A multiprocess future is not a formal class of futures by itself, but rather a convenient alias for either of the two.  When this is specified, multisession evaluation will be used unless multicore evaluation is supported.


### Cluster Futures
Cluster futures evaulates expression on an ad-hoc cluster that was set up via `parallel::makeCluster()`.  For instance, assume you have access to three nodes `n1`, `n2` and `n3`, you can use these for asynchronous evaluation as:
```r
<%=
## For the vignette we cannot assume nodes n1, n2 and n3 exist.
## The second best we can do is to use the local machine.
bfr <- withCapture({
hosts <- c("localhost", "localhost", "localhost")
cl <- parallel::makeCluster(hosts)
plan(cluster, cluster=cl)
<%@include file="future-1-overview-example2.R"%>
parallel::stopCluster(cl)
})
bfr <- gsub('"localhost", "localhost", "localhost"', '"n1", "n2", "n3"', bfr)
bfr
%>
```
Just as for the other asynchronous evaluation strategies, the output from `cat()` is not displayed on the current/calling machine.  Note that with proper configuration and automatic authentication setup, there is nothing preventing us from using the same approach for using a cluster of remote machines.  Finally, it is considered good style to shutdown the cluster when it is no longer needed, that is, calling `parallel::stopCluster(cl)`.  However, it will shut itself done if the main process is terminated.  For more information on how to setup and manage such clusters, see `help("makeCluster", package="parallel")`.


## ...

You are responsible for your own futures and how you choose to resolve them may differ depending on your needs and your resources.  The 'future' package provides two _synchronous_ futures, the "lazy" and "eager" futures, implemented by functions `lazy()` and `eager()`.
It also provides different types of _asynchronous_ futures, e.g. the "multicore" and the "multisession" futures, implemented by functions `multicore()` and  `multisession()`.  The multicore future is available on systems where R supports process forking, that is, on Unix-like operating systems, but not on Windows.  On non-supported systems, multicore futures automatically become eager futures.
The multisession future is available on all systems, including Windows, and instead of forking the current R process, it launches a set of R sessions in the background on which the multisession futures are evaluated.  Both multicore and multisession evaluation is agile to the number of cores available to the R session running, which includes acknowledging the `mc.cores` options among other settings.  For details, see `help("availableCores", package="future")`.
To use multicore futures where supported and otherwise multisession ones, one can use the more general _multiprocess_ futures, i.e. `plan(multiprocess)`.
There is also a more generic "cluster" future as implemented by `cluster()`, which makes it possible to use any type of cluster created by `parallel::makeCluster()`.



In principal, for explicit futures, the three most useful methods are:

* `f <- future({ expr })` - creates a future
* `v <- value(f)` - gets the value of the future (blocks if not yet resolved)
* `resolved(f)` - checks whether the future is resolved or not (without blocking)

For implicit futures, the three most useful methods are:
* `v %<-% { expr }` - creates promise to a future value
* `f <- futureOf(v)` - gets the future from a promise
* `resolved(f)` - checks whether the future is resolved or not (without blocking)





Note how the future is resolved as soon as we create it using `%<-%`.  This is because the default strategy for resolving futures is to evaluate them in an "eager" and synchronous manner closely immitating how R itself does it.  Later we will show how we can use different evaluation strategies, e.g. lazy or asynchronous multiprocess.




(using either the implicit or the explicit evaluation strategy).

In this case the future is unresolved until the point in time when we first ask for its value.  Below we will show how other types of evaluation strategies, including asynchronous ones, can be used.  Note also how the future is only resolved once; the second time we query its value it is instantaneously available.  The analogue to lazy futures in core R for this would be delayed assignments, e.g.
```r
> delayedAssign("v", {
+   message("Resolving...")
+   3.14
+ })
> v
Resolving...
[1] 3.14
> v
[1] 3.14
```


We could have also created explicit futures using the `f <- future({ expr })` and `x <- value(f)` constructs.  More precisely, we could achieve the same results using:
```r
> library(future)
> plan(lazy)
> f <- future({
+   message("Resolving...")
+   3.14
+ })
> v <- value(f)
Resolving...
> v
[1] 3.14
> value(f)
[1] 3.14
```
The closest analogue to this using core R functions would be:
```r
> f <- expression({
+   message("Resolving...")
+   3.14
+ })
> v <- eval(f)
Resolving...
[1] 3.14
> eval(f)
Resolving...
[1] 3.14
```
but that is how far the analogy goes.  Contrary to `expression()` + `eval()`, with futures the expression is only resolved once such that, if we query their values subsequently, the value is returned instantaneous.  This is true for all types of futures, regardless how they are resolved.


### The Future API
The above is true for all types of futures.  The future package itself implements two _synchronous_ mechanisms for "lazy" and "eager" futures, and a three _asynchronous_ ones for "multicore", "multisession" and "cluster" futures.  The synchronous futures, blocks the main process while being resolved, whereas the asynchronous futures do not block the main process.

Further strategies will be implemented by other packages extending the 'future' package.  For instance, the 'future.BatchJobs' package (to be published) resolves futures _asynchronously_ via any of the many backends that the '[BatchJobs]' framework provides, e.g. distributed on a compute cluster via a job queue/scheduler.

For troubleshooting, there is also a _transparent_ future, which can be specified as `plan(transparent)`.  A transparent future is technically an eager future with instant signaling of conditions (including errors and warnings) and where evaluation, and therefore also assignments, take place in the calling environment.  Transparent futures are particularly useful for troubleshooting errors.


### Promises of successful futures
An important part of a future is the fact that, although we do not necessarily control _when_ a future is resolved, we do have a "promise" that it _will_ be resolved (at least if its value is requested).  In other words, if we ask for the value of a future, we are guaranteed that the expression of the future will be evaluated and its value will be returned to us (or an error will be generated if the evaluation caused an error).  An alternative to a future-value pair of function calls is to use the `%<-%` infix assignment operator (also provided by the 'future' package).  For example,

```r
> plan(lazy)
> v %<-% {
+   message("Resolving...")
+   3.14
+ }
> v
Resolving...
[1] 3.14
```

This works by (i) creating a future and (ii) assigning its value to variable `v` as a _promise_.  Specifically, the expression/value assigned to variable `v` is promised to be evaluated (no later than) when it is requested.  Promises are built-in constructs of R (see `help(delayedAssign)`).
To get the future of a future variable, use the `futureOf()` function, e.g. `f <- futureOf(v)`.


### Eager, lazy and parallel futures
You are responsible for your own futures and how you choose to resolve them may differ depending on your needs and your resources.  The 'future' package provides two _synchronous_ futures, the "lazy" and "eager" futures, implemented by functions `lazy()` and `eager()`.
It also provides different types of _asynchronous_ futures, e.g. the "multicore" and the "multisession" futures, implemented by functions `multicore()` and  `multisession()`.  The multicore future is available on systems where R supports process forking, that is, on Unix-like operating systems, but not on Windows.  On non-supported systems, multicore futures automatically become eager futures.
The multisession future is available on all systems, including Windows, and instead of forking the current R process, it launches a set of R sessions in the background on which the multisession futures are evaluated.  Both multicore and multisession evaluation is agile to the number of cores available to the R session running, which includes acknowledging the `mc.cores` options among other settings.  For details, see `help("availableCores", package="future")`.
To use multicore futures where supported and otherwise multisession ones, one can use the more general _multiprocess_ futures, i.e. `plan(multiprocess)`.
There is also a more generic "cluster" future as implemented by `cluster()`, which makes it possible to use any type of cluster created by `parallel::makeCluster()`.

Since an asynchronous strategy is more likely to be used in practice, the built-in eager and lazy mechanisms try to emulate those as far as possible while at the same time evaluating them in a synchronous way.  For example, the default for all types of futures is that the expression is evaluated in _a local environment_ (cf. `help("local")`), which means that any assignments are done to local variables only - such that the environment of the main/calling process is unaffected.  Here is an example:

```r
> a <- 2.71
> x %<-% { a <- 3.14 }
> x
[1] 3.14
> a
[1] 2.71
```
This shows that `a` in the calling environment is unaffected by the expression evaluated by the future.


### Different strategies for different futures
Sometimes one may want to use an alternative evaluation strategy for a specific future.  Although one can use `old <- plan(new)` and afterward `plan(old)` to temporarily switch strategies, a simpler approach is to use the `%plan%` operator, e.g.
```r
> plan(eager)
> a <- 0
> x %<-% { 3.14 }
> y %<-% { a <- 2.71 } %plan% lazy(local=FALSE, globals=FALSE)
> x
[1] 3.14
> a
[1] 0
> y
[1] 2.71
> a
[1] 2.71
```
Above, the expression for `x` is evaluated eagerly (in a local environment), whereas the one for `y` is evaluated lazily in the calling environment.


### Nested futures
It is possible to nest futures in multiple levels and each of the nested futures may be resolved using a different strategy, e.g.
```r
> plan(lazy)
> c %<-% {
+   message("Resolving 'c'")
+   a %<-% {
+     message("Resolving 'a'")
+     3
+   } %plan% eager
+   b %<-% {
+     message("Resolving 'b'")
+     -9 * a
+   }
+   message("Local variable 'x'")
+   x <- b / 3
+   abs(x)
+ }
> d <- 42
> d
[1] 42
> c
Resolving 'c'
Resolving 'a'
Local variable 'x'
Resolving 'b'
[1] 6
```

When using asynchronous (multicore, multisession and cluster) futures, recursive asynchronous evaluation done by mistake is protected against by forcing eager futures and option `mc.cores` to zero (number of _additional_ cores available for processing in addition to the main process) to lower the risk for other multicore mechanisms to spawn off additional cores.
In order to use other types of future strategies for the nested layers of futures, one may give a list of strategies to `plan()`.  For more details, see Vignette '[Futures in R: Future Topologies]'.


## Assigning futures to environments and list environments
The `%<-%` assignment operator _cannot_ be used in all cases where the regular `<-` assignment operator can be used.  For instance, it is _not_ possible to assign future values to a _list_;

```r
> x <- list()
> x$a %<-% { 2.71 }
Error: Subsetting can not be done on a 'list'; only to an environment: 'x$a'
```

This is because _promises_ themselves cannot be assigned to lists.  More precisely, the limitation of future assignments are the same as those for assignments via the `assign()` function, which means you can only assign _future values_ to environments (defaulting to the current environment) but nothing else, i.e. not to elements of a vector, matrix, list or a data.frame and so on.  To assign a future value to an environment, do:

```r
> env <- new.env()
> env$a %<-% { 1 }
> env[["b"]] %<-% { 2 }
> name <- "c"
> env[[name]] %<-% { 3 }
> as.list(env)
$a
[1] 1

$b
[1] 2

$c
[1] 3
```

If _indexed subsetting_ is needed for assignments, the '[listenv]' package provides _list environments_, which technically are environments, but at the same time emulate how lists can be indexed.  For example,
```r
> library(listenv)
> x <- listenv()
> for (ii in 1:3) {
+   x[[ii]] %<-% { rnorm(ii) }
+ }
> names(x) <- c("a", "b", "c")
```
Future values of a list environment can be retrieved individually as `x[["b"]]` and `x$b`, but also as `x[[2]]`, e.g.
```r
> x[[2]]
[1] -0.6735019  0.9873067
> x$b
[1] -0.6735019  0.9873067
```
Just as for any type of environment, all  values of a list environment can be retrieved as a list using `as.list(x)`.  However, remember that future assignments were used, which means that unless they are all resolved, the calling process will block until all values are available.


## Failed futures
Sometimes the future is not what you expected.  If an error occurs while evaluating a future, the error is propagated and thrown as an error in the calling environment _when the future value is requested_.  For example,
```r
> plan(lazy)
> f <- future({
+   message("Resolving...")
+   stop("Whoops!")
+   42
+ })
> value(f)
Resolving...
Error in eval(expr, envir, enclos) : Whoops!
```
The error is thrown each time the value is requested, that is, trying to get the value again will generate the same error:
```r
> value(f)
Error in eval(expr, envir, enclos) : Whoops!
```
Note how the future expression is only evaluated once although the error itself is re-thrown each time the value is required subsequently.

Exception handling of future assignments via `%<-%` works analogously, e.g.
```r
> plan(lazy)
> x %<-% {
+   message("Resolving...")
+   stop("Whoops!")
+   42
+ }
> y <- 3.14
> y
[1] 3.14
> x
Resolving...
Error in eval(expr, envir, enclos) : Whoops!
> x
Error in eval(expr, envir, enclos) : Whoops!
In addition: Warning message:
restarting interrupted promise evaluation
```


## Globals
Whenever an R expression is to be evaluated asynchronously (in parallel) or via lazy evaluation, global objects need to be identified and passed to the evaluator.  They need to be passed exactly as they were at the time the future was created, because, for a lazy future, globals may otherwise change between when it is created and when it is resolved.

The future package tries to automate the identification of globals in future expressions.  It does so with help of the [globals] package.  If a global variable is identified, it is captured and made available to the evaluator of the future, e.g. it is exported to the work environment of an R session running in the background.  If it identifies a symbol that it believes is a global object in the future expression, but it fails to locate it in the work environment, an error is thrown immediately (minimizing the risk for runtime errors occurring much later).  For instance,
```r
> x <- 5.0
> y %<-% { a * x }
Error in globalsOf(expr, envir = envir, substitute = FALSE, tweak = tweak,  :
Identified a global by static code inspection, but failed to locate the
corresponding object in the relevant environments: 'a'
> a <- 1.8
> y %<-% { a * x }
> y
[1] 9
```
Moreover, if a global is defined in a packages, for instance a function, then that global is not exported but instead it is made sure that the corresponding package is attached when the future is evaluated.  This not only reflects the setup of the main R session, but it also minimizes the need for exporting globals, which can save bandwidth and time, especially when using remote compute nodes.

Having said this, it is a challenging problem to identify globals from static code inspection.  There will always be corner cases of globals that either fails to be identified by static code inspection or that are incorrectly identified as global variables.  Vignette '[Futures in R: Common Issues with Solutions]' provides examples of common cases and explains how to avoid them.
If you suspect that a global variable is not properly identified, it is often helpful for troubleshooting to run the code interactively using synchronous futures, i.e. _eager_ or _lazy_.  If there is an error, it is then possible to use `traceback()` and other debugging tools.

For consistency, all types of futures validates globals upon creation (`globals=TRUE` is the default).  Now, since eager futures are resolved immediately upon creation, any globals will also be resolved at this time and therefore there is actually no need for globals to be identified and validated.  Similarly, because multicore futures fork the main R session when created, globals are automatically "frozen" for each multicore future.  If you prefer not to use the strict validation of globals that the future package does when using these two types of futures, you can disable the check by specifying `plan(eager, globals=FALSE)` and `plan(multicore, globals=FALSE)`, respectively.


## Demos
To see a live illustration how different types of futures are evaluated, run the Mandelbrot demo of this package.  First try with the eager evaluation,
```r
library(future)
plan(eager)
demo("mandelbrot", package="future", ask=FALSE)
```
which closely imitates how the script would run if futures were not used.  Then try the same using lazy evaluation,
```r
plan(lazy)
demo("mandelbrot", package="future", ask=FALSE)
```
and see if you can notice the difference in how and when statements are evaluated.
You may also try multiprocess evaluation, which calculates the different Mandelbrot planes using parallel R processes running in the background.  Try,
```r
plan(multiprocess)
demo("mandelbrot", package="future", ask=FALSE)
```
This will use multicore processing if you are on a system where R supports process forking, otherwise (such as on Windows) it will use multisession processing.

Finally, if you have access to multiple machines you can try to setup a cluster of workers and use them, e.g.
```r
cl <- parallel::makeCluster(c("n2", "n5", "n6", "n6", "n9"))
plan(cluster, cluster=cl)
demo("mandelbrot", package="future", ask=FALSE)
```
Don't forget to call `parallel::stopCluster(cl)` when you're done with this cluster.  If you forget, it will automatically shutdown when you close your R session.



## Contributing
The goal of this package is to provide a standardized and unified API for using futures in R.  What you are seeing right now is an early but sincere attempt to achieve this goal.  If you have comments or ideas on how to improve the 'future' package, I would love to hear about them.  The preferred way to get in touch is via the [GitHub repository](https://github.com/HenrikBengtsson/future/), where you also find the latest source code.  I am also open to contributions and collaborations of any kind.


[BatchJobs]: http://cran.r-project.org/package=BatchJobs
[listenv]: http://cran.r-project.org/package=listenv
[globals]: http://cran.r-project.org/package=globals
[Futures in R: Common Issues with Solutions]: future-2-issues.html
[Futures in R: Future Topologies]: future-3-topologies.html
---
Copyright Henrik Bengtsson, 2015-2016
