% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/future.R, R/futureCall.R
\name{future}
\alias{future}
\alias{futureCall}
\title{Create a future}
\usage{
future(expr, envir = parent.frame(), substitute = TRUE,
  evaluator = plan(), ...)

futureCall(FUN, args = NULL, envir = parent.frame(), globals = TRUE,
  evaluator = plan(), ...)
}
\arguments{
\item{expr}{An R \link[base]{expression}.}

\item{envir}{The \link{environment} from where global
objects should be identified.  Depending on "evaluator",
it may also be the environment in which the expression
is evaluated.}

\item{substitute}{If TRUE, argument \code{expr} is
\code{\link[base]{substitute}()}:ed, otherwise not.}

\item{evaluator}{The actual function that evaluates
the future expression and returns a \link{Future}.
The evaluator function should accept all of the same
arguments as the ones listed here
(except \code{evaluator}, \code{FUN} and \code{args}).
The default evaluator function is the one that the user
has specified via \code{\link{plan}()}.}

\item{...}{Additional arguments passed to the "evaluator".}

\item{FUN}{A function object.}

\item{args}{A list of arguments passed to function \code{FUN}.}

\item{globals}{A logical, a character vector,
or a named list for controlling how globals are handled.
For details, see below section.
This argument can be specified also for \code{future()}
in which case it is passed via the \dots arguments.}
}
\value{
A \link{Future}.
}
\description{
Creates a future from an expression.
The state of the future is either unresolved or resolved,
which can be checked using \code{\link{resolved}()}.
When it becomes resolved, at some point in the future,
its value can be retrieved using \code{\link{value}()}.
}
\section{Globals used by future expressions}{

Global objects (short \emph{globals}) are objects (e.g. variables and
functions) that are needed in order for the future expression to be
evaluated while not being local objects that are defined by the future
expression. For example, in
\preformatted{
  a <- 42
  f <- future({ b <- 2; a * b })
}
variable \code{a} is a global of future assignment \code{f} whereas
\code{b} is a local variable.
In order for the future to be resolved successfully (and correctly),
all globals need to gathered when the future is created such that
they are available whenever and wherever the future is resolved.

The default behavior (\code{globals = TRUE}) of all evaluator functions,
is that globals are automatically identified and gathered.
More precisely, globals are identified via code inspection of the
future expression \code{expr} and their values are retrieved with
environment \code{envir} as the starting point (basically via
\code{get(global, envir=envir, inherits=TRUE)}).
In most cases automatic collection of globals is sufficient and
less tedious and error prone than to manually specifying them.

However, for full control, it is also possible to explicitly specify
exactly which the globals are by providing their names as a character
vector.
In the above example, we could use
\preformatted{
  a <- 42
  f <- future({ b <- 2; a * b }, globals = "a")
}

Yet another alternative is to explicitly specify also their values
using a named list as in
\preformatted{
  a <- 42
  f <- future({ b <- 2; a * b }, globals = list(a = a))
}
or
\preformatted{
  f <- future({ b <- 2; a * b }, globals = list(a = 42))
}

Specifying globals explicitly avoids the overhead added from
automatically identifying the globals and gathering their values.
Futhermore, if we know that the future expression does not make use
of any global variables, we can disable the automatic search for
globals by using
\preformatted{
  f <- future({ a <- 42; b <- 2; a * b }, globals = FALSE)
}

Future expressions often make use of functions from one or more packages.
As long as these functions are part of the set of globals, the future
package will make sure that those packages are attached when the future
is resolved.  Because there is no need for such globals to be frozen
or exported, the future package will not export them, which reduces
the amount of transferred objects.
For example, in
\preformatted{
  x <- rnorm(1000)
  f <- future({ median(x) })
}
variable \code{x} and \code{median()} are globals, but only \code{x}
is exported whereas \code{median()}, which is part of the \pkg{stats}
package, is not exported.  Instead the \pkg{stats} package is made
sure to be on the search path when the future expression is evaluated.
Effectively, the above becomes
\preformatted{
  x <- rnorm(1000)
  f <- future({
    library("stats")
    median(x)
  })
}
To manually specify this, one can either do
\preformatted{
  x <- rnorm(1000)
  f <- future({
    median(x)
  }, globals = list(x = x, median = stats::median)
}
or
\preformatted{
  x <- rnorm(1000)
  f <- future({
    library("stats")
    median(x)
  }, globals = list(x = x))
}
Both are effectively the same.

When using future assignments (via \code{\link{\%<-\%}}) globals
can be specified analogously using the \code{\link{\%globals\%}}
operator, e.g.
\preformatted{
  x <- rnorm(1000)
  y %<-% { median(x) } %globals% list(x = x, median = stats::median)
}
}
\examples{
## Use lazy futures
plan(lazy)

f <- future({
  a <- 7
  b <- 3
  c <- 2
  a * b * c
})

print(resolved(f))
y <- value(f)
print(y)
}
\seealso{
It is highly recommended that the evaluator is \emph{non-blocking}
(returns immediately), but it is currently not required.
The default evaluator function is \code{\link{eager}()},
but this can be changed via \code{\link{plan}()} function.
}

