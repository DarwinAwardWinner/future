% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/lazy.R
\name{lazy}
\alias{lazy}
\title{A lazy future represents a future whose value will be resolved at the time when it is requested}
\usage{
lazy(expr, envir = parent.frame(), substitute = TRUE, globals = TRUE,
  local = TRUE, ...)
}
\arguments{
\item{expr}{An R \link[base]{expression}.}

\item{envir}{The \link{environment} in which the evaluation
is done (or inherits from if \code{local} is TRUE).}

\item{substitute}{If TRUE, argument \code{expr} is
\code{\link[base]{substitute}()}:ed, otherwise not.}

\item{globals}{If TRUE, global objects are resolved at the point of
time when the future is created, otherwise they are resolved when
the future is resolved.}

\item{local}{If TRUE, the expression is evaluated such that
all assignments are done to local temporary environment, otherwise
the assignments are done in the calling environment.}

\item{...}{Not used.}
}
\value{
A \link{LazyFuture}.
}
\description{
A lazy future is a future that uses lazy evaluation, which means
that its \emph{value is only computed and resolved at the time when the
value is requested}.  This means that the future will not be resolved
if the value is never requested.
}
\details{
Note that the "lazy future" strategy also applies to any global variables
used in the expression, i.e. if the value of a global variables changes
between the time point the lazy future was created and its acutally
resolvement, then the value will be based on the most recent value of
global variable (not the value at the time the future was created).
This is a special "feature" due to the "lazy" (delayed) evaluation of
this particular future.  Ideally, globals are resolved at the time when
the future is created.  See example for an illustration of this.

This function can be registered as the default \link{future} evaluator,
i.e. \code{plan(lazy)}.
}
\examples{
## A global variable
a <- 0

## Create lazy future
f <- lazy({
  b <- 3
  c <- 2
  a * b * c
})

## Although 'f' is a _lazy_ future and therefore
## resolved/evaluates the future expression only
## when the value is requested, any global variables
## identified in the expression (here 'a') are
## "frozen" at the time point when the future is
## created.  Because of this, 'a' preserved the
## zero value although we reassign it below
a <- 7
v <- value(f)
print(v)
stopifnot(v == 0)

}
\seealso{
Internally, \code{\link[base]{delayedAssign}()} is utilized to
create a "\emph{\link[base]{promise}}", which hold the future's value.
}

